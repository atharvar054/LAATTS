<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Athlete Training Tracker System</title>
    <!-- Load Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load React, ReactDOM, and Babel for JSX in the browser -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-Iw2f9rqvDqk2F8VxGQF0mZpXG6XyQJ3X0mY9u8R2u2M3jZlCk0XWg2YtA8cIh9p5" crossorigin="anonymous"></script>
    
    <!-- Custom styling setup -->
    <script>
        // Define custom colors for Tailwind to match instructions
        const tailwindConfig = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary-indigo': '#4F46E5',
                        'light-slate': '#F1F5F9',
                    }
                }
            }
        };
        // Apply Tailwind config 
        if (typeof tailwind !== 'undefined' && typeof tailwind.config === 'function') {
            tailwind.config = tailwindConfig;
        } else if (window.tailwind) {
            window.tailwind.config = tailwindConfig;
        }
    </script>
     <!-- Custom CSS for visual effects and global styles -->
     <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
        }
        .text-shadow-lg {
            text-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body>
    <!-- Root element where the React app will be mounted -->
    <div id="root"></div>

    <script type="text/babel">
        // --- Audio Utility ---
        const playBeep = () => {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); 
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.01);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);

                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);

            } catch (e) {
                console.error("Web Audio API not supported or failed to start: ", e);
            }
        };

        // FIXED: Using React, ReactDOM from the global scope after they load.
        const { useState, useEffect, useCallback, useMemo, useRef } = React;

        /**
         * Scoreboard component displays session stats and controls.
         */
        const Scoreboard = ({ stats, mode, onStart, onStop, onReset }) => {
            const { reps, timer, isRunning } = stats;

            const formatTime = (seconds) => {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            };

            return (
                <div className="bg-white p-6 rounded-2xl shadow-xl w-full">
                    <h3 className="text-xl font-bold mb-4 text-gray-800">Session Scoreboard</h3>
                    
                    <div className="grid grid-cols-3 gap-4 text-center mb-6">
                        <div className="p-3 bg-light-slate rounded-lg">
                            <p className="text-xs font-medium text-gray-500 uppercase">Mode</p>
                            <p className="text-lg font-semibold text-primary-indigo capitalize">{mode.replace('Mode', '')}</p>
                        </div>
                        <div className="p-3 bg-light-slate rounded-lg">
                            <p className="text-xs font-medium text-gray-500 uppercase">Total Reps</p>
                            <p className="text-3xl font-extrabold text-gray-900">{reps}</p>
                        </div>
                        <div className="p-3 bg-light-slate rounded-lg">
                            <p className="text-xs font-medium text-gray-500 uppercase">Time Elapsed</p>
                            <p className="text-3xl font-extrabold text-gray-900">{formatTime(timer)}</p>
                        </div>
                    </div>

                    <div className="flex justify-between space-x-3">
                        <button
                            onClick={isRunning ? onStop : onStart}
                            className={`flex-1 py-3 rounded-xl font-bold transition duration-300 shadow-md 
                                ${isRunning 
                                    ? 'bg-red-500 hover:bg-red-600 text-white' 
                                    : 'bg-green-500 hover:bg-green-600 text-white'}`}
                        >
                            {isRunning ? 'STOP' : 'START'}
                        </button>
                        <button
                            onClick={onReset}
                            className="flex-1 py-3 rounded-xl font-bold bg-yellow-400 text-gray-800 hover:bg-yellow-500 transition duration-300 shadow-md"
                        >
                            RESET
                        </button>
                    </div>
                </div>
            );
        };

        /**
         * Animated Rep Counter component.
         */
        const RepCounter = ({ reps, className = '', color = 'text-white' }) => {
            const [animate, setAnimate] = useState(false);

            useEffect(() => {
                if (reps > 0) {
                    setAnimate(true);
                    playBeep(); 
                    
                    const timeout = setTimeout(() => setAnimate(false), 200);
                    return () => clearTimeout(timeout);
                }
            }, [reps]);

            const animationClasses = animate 
                ? 'scale-110 !text-yellow-300' 
                : 'scale-100';

            return (
                <div className={`
                    text-7xl font-extrabold 
                    transition-all duration-150 ease-out 
                    ${color} ${animationClasses} ${className}
                `}>
                    {reps}
                </div>
            );
        };


        /**
         * Laser Mode component: Simulates a target tracking grid.
         */
        const LaserMode = ({ stats, setStats, isRunning }) => {
            const GRID_SIZE = 9; 
            const [targetIndex, setTargetIndex] = useState(null);

            const handleIntersection = useCallback(() => {
                if (!isRunning || targetIndex === null) return;
                
                setStats(prev => ({ ...prev, reps: prev.reps + 1 }));

                let nextTarget;
                do {
                    nextTarget = Math.floor(Math.random() * GRID_SIZE);
                } while (nextTarget === targetIndex); 
                
                setTargetIndex(nextTarget);

            }, [isRunning, targetIndex, setStats]);

            useEffect(() => {
                if (!isRunning) {
                    setTargetIndex(null);
                    return;
                }

                if (targetIndex === null) {
                    setTargetIndex(Math.floor(Math.random() * GRID_SIZE));
                }

                // SIMULATION OF EXTERNAL LASER HARDWARE (Changes target every 3 seconds)
                const targetChangeInterval = setInterval(() => {
                    if (isRunning) {
                        let nextTarget;
                        do {
                            nextTarget = Math.floor(Math.random() * GRID_SIZE);
                        } while (nextTarget === targetIndex);
                        setTargetIndex(nextTarget);
                    }
                }, 3000); 

                return () => clearInterval(targetChangeInterval);
            }, [isRunning, targetIndex]);

            return (
                <div className="flex flex-col items-center w-full">
                    <h2 className="text-3xl font-extrabold text-gray-900 mb-4">Laser Mode Training</h2>
                    
                    <div className="mb-8">
                        <p className="text-sm font-medium text-gray-500 uppercase text-center mb-1">Total Intersections</p>
                        <RepCounter reps={stats.reps} className="!text-8xl !text-primary-indigo" color="text-primary-indigo" />
                    </div>

                    <div className="w-full max-w-lg aspect-square bg-gray-100 p-4 sm:p-6 rounded-2xl shadow-inner grid grid-cols-3 gap-3 sm:gap-4">
                        {[...Array(GRID_SIZE)].map((_, index) => (
                            <div
                                key={index}
                                className={`flex items-center justify-center p-4 rounded-xl transition duration-500 ease-in-out cursor-pointer 
                                    ${index === targetIndex && isRunning
                                        ? 'bg-red-500 shadow-2xl shadow-red-500/50 transform scale-110 border-4 border-white'
                                        : 'bg-light-slate hover:bg-gray-200'}
                                    ${index !== targetIndex && isRunning ? 'border-2 border-gray-300' : ''}
                                `}
                                onClick={handleIntersection} // User clicks to simulate intersecting the laser/target
                            >
                                <span className="text-xl font-bold text-gray-700 select-none">
                                    {index + 1}
                                </span>
                            </div>
                        ))}
                    </div>

                    <p className="mt-6 text-center text-gray-600">
                        {isRunning && targetIndex !== null 
                            ? `Current Target: Point ${targetIndex + 1}. Click any square to simulate a hit!`
                            : 'Press START on the scoreboard to begin the laser session.'}
                    </p>
                </div>
            );
        };

        /**
         * Camera Mode component: Simulates exercise tracking via webcam.
         */
        const CameraMode = ({ stats, setStats, isRunning, currentExercise, setCurrentExercise }) => {
            const videoRef = React.useRef(null);
            const [isCalibrating, setIsCalibrating] = useState(false);
            const [backendImage, setBackendImage] = useState(null);
            const socketRef = useRef(null);
            
            // --- Pose Detection State (using useRef for mutable, non-rendering state) ---
            const detectionRefs = useRef({
                repCount: 0,
                downPhase: false, 
                jumpPhase: false, 
                lastPose: null,
                baselineTorsoAngle: null,
                baselineFootY: null,
                lastRepTime: 0, 
                initialAngles: [],
                initialFootYs: [],
                calibFrames: 0,
            });
            
            // --- Thresholds (Used by onPoseDetected logic) ---
            const MIN_REP_INTERVAL = 500; 

            // Sit-up thresholds
            const SITUP_DOWN_ANGLE = 80;
            const SITUP_UP_ANGLE = 140; 
            const SITUP_MIN_DELTA = 12; 
            
            // Skipping thresholds
            const MIN_JUMP_HEIGHT = 20;
            const LAND_TOLERANCE_PX = 8; 

            // Helper: Mock function for getTorsoAngle (returns angle from pose data)
            const getTorsoAngle = (pose) => {
                return pose.torsoAngle; 
            };

            // Helper: Mock function for getAverageFootY (returns y-position from pose data)
            const getAverageFootY = (pose) => {
                return pose.footY;
            };

            // Core pose detection and counting logic
            const onPoseDetected = useCallback((pose) => {
                if (!pose) return;

                const refs = detectionRefs.current;
                const { lastPose } = refs;
                
                let torsoAngle = getTorsoAngle(pose);
                let footY = getAverageFootY(pose);

                // --- 1. Calibration Check ---
                if (refs.baselineTorsoAngle === null) {
                    refs.lastPose = { torsoAngle, footY };
                    return;
                }
                
                const now = Date.now();
                let repCompleted = false;

                if (currentExercise === 'sit-ups') {
                    // ========== SIT-UPS DETECTION ==========
                    if (!refs.downPhase) {
                        if (torsoAngle < SITUP_DOWN_ANGLE &&
                            lastPose && lastPose.torsoAngle - torsoAngle > SITUP_MIN_DELTA) {
                            refs.downPhase = true;
                        }
                    } else {
                        if (torsoAngle > SITUP_UP_ANGLE &&
                            lastPose && torsoAngle - lastPose.torsoAngle > SITUP_MIN_DELTA) {
                            repCompleted = true;
                            refs.downPhase = false;
                        }
                    }
                } 
                
                else if (currentExercise === 'skipping') {
                    // ========== SKIPPING DETECTION (Action-based, two-phase logic) ==========
                    let jumpHeight = refs.baselineFootY - footY;

                    if (!refs.jumpPhase) {
                        // Phase 1: Jump detected (feet off ground)
                        if (jumpHeight > MIN_JUMP_HEIGHT) {
                            refs.jumpPhase = true;
                        }
                    } else {
                        // Phase 2: Land detected (feet back on ground)
                        if (footY >= refs.baselineFootY - LAND_TOLERANCE_PX) { 
                            repCompleted = true;
                            refs.jumpPhase = false;
                        }
                    }
                }
                
                // --- 3. Debounce and Update State ---
                if (repCompleted && (now - refs.lastRepTime) >= MIN_REP_INTERVAL) {
                    refs.repCount++;
                    refs.lastRepTime = now;
                    setStats(prev => ({ ...prev, reps: refs.repCount })); 
                    console.log(`Rep counted for ${currentExercise}:`, refs.repCount);
                }
                
                refs.lastPose = { torsoAngle, footY };
            }, [setStats, currentExercise, SITUP_DOWN_ANGLE, SITUP_UP_ANGLE, SITUP_MIN_DELTA, MIN_JUMP_HEIGHT, LAND_TOLERANCE_PX, MIN_REP_INTERVAL]);


            // --- Webcam Stream Setup ---
            useEffect(() => {
                // When running with backend, do not start local webcam; backend provides frames
                if (!isRunning) {
                    if (socketRef.current) {
                        socketRef.current.disconnect();
                        socketRef.current = null;
                    }
                    setBackendImage(null);
                    return;
                }

                // Connect to backend socket only when a camera exercise is selected
                if (currentExercise) {
                    try {
                        const s = io();
                        socketRef.current = s;
                        s.on('connect', () => {
                            console.log('Socket connected');
                        });
                        s.on('video_feed', ({ image, count }) => {
                            setBackendImage(`data:image/jpeg;base64,${image}`);
                            setStats(prev => ({ ...prev, reps: count }));
                        });
                    } catch (e) {
                        console.error('Socket connection failed', e);
                    }
                }

                return () => {
                    if (socketRef.current) {
                        socketRef.current.disconnect();
                        socketRef.current = null;
                    }
                };
            }, [isRunning, currentExercise, setStats]);

            // --- SIMULATION LOGIC: Combined Motion Loop (20 FPS) ---
            useEffect(() => {
                if (!isRunning || !currentExercise) return;
                
                // Reset and start calibration UI state
                setIsCalibrating(true);
                const refs = detectionRefs.current;
                refs.baselineTorsoAngle = null;
                refs.initialAngles = [];
                
                let simData = {
                    angle: 165, // Torso angle for sit-ups (starting up)
                    angleDirection: 'down',
                    y: 500,     // Foot Y position for skipping (starting on ground)
                    yDirection: 'up',
                };
                const baselineFootYMock = 500;
                
                const simulationInterval = setInterval(() => {
                    
                    let mockPose;

                    if (currentExercise === 'sit-ups') {
                        if (simData.angleDirection === 'down') {
                            simData.angle -= 5;
                            if (simData.angle <= 60) {
                                simData.angleDirection = 'up';
                            }
                        } else {
                            simData.angle += 5;
                            if (simData.angle >= 165) {
                                simData.angleDirection = 'down'; 
                            }
                        }
                        mockPose = { torsoAngle: simData.angle, footY: baselineFootYMock };

                    } else if (currentExercise === 'skipping') {
                        if (simData.yDirection === 'up') {
                            simData.y -= 7; 
                            if (baselineFootYMock - simData.y >= MIN_JUMP_HEIGHT + 10) {
                                simData.yDirection = 'down';
                            }
                        } else {
                            simData.y += 7; 
                            if (simData.y >= baselineFootYMock) {
                                simData.y = baselineFootYMock;
                                simData.yDirection = 'up'; 
                            }
                        }
                        mockPose = { torsoAngle: 165, footY: simData.y };
                    }

                    // Calibration logic running inside the interval
                    if (refs.baselineTorsoAngle === null) {
                        if (refs.initialAngles.length < 40) {
                            refs.initialAngles.push(mockPose.torsoAngle);
                            refs.initialFootYs.push(mockPose.footY);
                        } else {
                            // Finalize calibration after ~2 seconds (40 frames @ 20 FPS)
                            refs.baselineTorsoAngle = refs.initialAngles.reduce((a, b) => a + b, 0) / refs.initialAngles.length;
                            refs.baselineFootY = refs.initialFootYs.reduce((a, b) => a + b, 0) / refs.initialFootYs.length;
                            setIsCalibrating(false);
                        }
                    }

                    // Call the integrated detection logic
                    if (mockPose) {
                        onPoseDetected(mockPose);
                    }

                }, 50); // High frequency loop (20 FPS)

                return () => {
                    clearInterval(simulationInterval);
                    setIsCalibrating(false);
                    // Reset all detection refs on stop/change
                    detectionRefs.current = {
                        repCount: 0, downPhase: false, jumpPhase: false, lastPose: null,
                        baselineTorsoAngle: null, baselineFootY: null, lastRepTime: 0,
                        initialAngles: [], initialFootYs: [], calibFrames: 0,
                    };
                };
            }, [isRunning, currentExercise, onPoseDetected, MIN_JUMP_HEIGHT]); 


            // Function to trigger a single rep detection for manual testing 
            const mockManualRep = useCallback(() => {
                if (!isRunning || !currentExercise || isCalibrating) return;
                
                const refs = detectionRefs.current;
                const now = Date.now();
                if (now - refs.lastRepTime >= MIN_REP_INTERVAL) {
                    refs.repCount++;
                    refs.lastRepTime = now;
                    setStats(prev => ({ ...prev, reps: refs.repCount }));
                }

            }, [isRunning, currentExercise, isCalibrating, setStats, MIN_REP_INTERVAL]);


            return (
                <div className="flex flex-col items-center w-full">
                    <h2 className="text-3xl font-extrabold text-gray-900 mb-6">Camera Mode Training</h2>

                    <div className="flex space-x-4 mb-8">
                        {['Sit-Ups', 'Skipping'].map(ex => (
                            <button
                                key={ex}
                                onClick={() => setCurrentExercise(ex.toLowerCase())}
                                className={`px-6 py-3 rounded-full font-semibold transition duration-300 shadow-lg 
                                    ${currentExercise === ex.toLowerCase()
                                        ? 'bg-primary-indigo text-white shadow-indigo-500/40'
                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}
                                `}
                                disabled={isRunning}
                            >
                                {ex}
                            </button>
                        ))}
                    </div>

                    {currentExercise && isRunning ? (
                        <div className="relative w-full max-w-xl aspect-video rounded-2xl overflow-hidden shadow-2xl bg-black">
                            {/* Backend Video Feed */}
                            {backendImage ? (
                                <img src={backendImage} alt="Video" className="w-full h-full object-cover" />
                            ) : (
                                <div className="w-full h-full flex items-center justify-center text-white">Waiting for video…</div>
                            )}

                            {/* Central Overlay for Animated Rep Count */}
                            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-10">
                                <RepCounter reps={stats.reps} className="!text-9xl text-shadow-lg" color="text-white" />
                            </div>
                            <div className="absolute top-4 right-4 bg-white/90 text-primary-indigo text-lg font-bold px-3 py-1 rounded-full shadow-xl capitalize z-20">
                                {currentExercise}
                            </div>
                        </div>
                    ) : (
                        <div className="w-full max-w-xl p-10 text-center bg-white rounded-2xl shadow-xl border border-gray-100">
                            <p className="text-lg text-gray-500">
                                Select an exercise and press **START** on the scoreboard to begin your camera session.
                            </p>
                        </div>
                    )}
                </div>
            );
        };


        /**
         * Main application component.
         */
        const App = () => {
            const [mode, setMode] = useState('landing');
            const [stats, setStats] = useState({
                reps: 0,
                timer: 0,
                isRunning: false,
            });
            const [cameraExercise, setCameraExercise] = useState('');

            const handleStart = useCallback(() => {
                if (mode === 'camera' && !cameraExercise) {
                    console.error("Please select an exercise (Sit-Ups or Skipping) first.");
                    return;
                }
                // Start backend mode
                if (mode === 'camera') {
                    const backendMode = cameraExercise === 'sit-ups' ? 'squats' : 'skipping';
                    fetch(`/start_mode?mode=${encodeURIComponent(backendMode)}`)
                        .then(() => setStats(prev => ({ ...prev, isRunning: true })))
                        .catch(err => console.error('Failed to start mode', err));
                    return;
                }
                setStats(prev => ({ ...prev, isRunning: true }));
            }, [mode, cameraExercise]);

            const handleStop = useCallback(() => {
                if (mode === 'camera') {
                    fetch('/stop_mode')
                        .finally(() => setStats(prev => ({ ...prev, isRunning: false })));
                    return;
                }
                setStats(prev => ({ ...prev, isRunning: false }));
            }, [mode]);

            const handleReset = useCallback(() => {
                if (mode === 'camera') {
                    fetch('/stop_mode').finally(() => {
                        setStats({ reps: 0, timer: 0, isRunning: false });
                        setMode('landing');
                        setCameraExercise('');
                    });
                    return;
                }
                setStats({ reps: 0, timer: 0, isRunning: false });
                if (mode !== 'landing') setMode('landing');
                setCameraExercise('');
            }, [mode]);


            // --- Global Timer Logic ---
            useEffect(() => {
                let interval = null;
                if (stats.isRunning) {
                    interval = setInterval(() => {
                        setStats(prev => ({ ...prev, timer: prev.timer + 1 }));
                    }, 1000);
                } else if (!stats.isRunning && stats.timer !== 0) {
                    clearInterval(interval);
                }
                return () => clearInterval(interval);
            }, [stats.isRunning, setStats]);


            // --- Render Logic ---

            let content;
            const currentModeName = useMemo(() => {
                switch (mode) {
                    case 'laser': return 'Laser Mode';
                    case 'camera': return 'Camera Mode';
                    default: return 'No Active Mode';
                }
            }, [mode]);


            if (mode === 'landing') {
                content = (
                    <div className="text-center bg-white p-8 sm:p-12 lg:p-16 rounded-3xl shadow-2xl border border-gray-100">
                        <h1 className="text-4xl sm:text-5xl lg:text-6xl font-extrabold text-gray-900 leading-tight mb-4">
                            Athlete Training System
                        </h1>
                        <p className="text-lg sm:text-xl text-gray-500 max-w-3xl mx-auto mb-10">
                            Select a training mode to start your high-performance session.
                        </p>
                        <div className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-8 justify-center">
                            <button
                                onClick={() => setMode('laser')}
                                className="bg-primary-indigo text-white px-8 py-4 rounded-2xl text-xl font-bold shadow-lg hover:bg-indigo-600 transition duration-300 transform hover:scale-105 w-full sm:w-64"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 inline mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" />
                                </svg>
                                Laser Mode
                            </button>
                            <button
                                onClick={() => setMode('camera')}
                                className="bg-green-500 text-white px-8 py-4 rounded-2xl text-xl font-bold shadow-lg hover:bg-green-600 transition duration-300 transform hover:scale-105 w-full sm:w-64"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 inline mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.218A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.218a2 2 0 001.664.89H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                                </svg>
                                Camera Mode
                            </button>
                        </div>
                    </div>
                );
            } else {
                // Content for Laser or Camera mode
                content = (
                    <div className="flex flex-col lg:flex-row gap-8 w-full">
                        {/* Scoreboard Panel - Fixed width/Order 1 on mobile */}
                        <div className="lg:w-1/3 order-last lg:order-first">
                            <Scoreboard 
                                stats={stats} 
                                mode={currentModeName} 
                                onStart={handleStart} 
                                onStop={handleStop} 
                                onReset={handleReset} 
                            />
                            <button
                                onClick={() => handleReset()}
                                className="w-full mt-4 py-2 rounded-xl font-semibold bg-gray-100 text-gray-600 hover:bg-gray-200 transition duration-300"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 inline mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8m-11 5h14a2 2 0 002-2v-3.5a2 2 0 00-2-2h-14a2 2 0 00-2 2V17a2 2 0 002 2z" />
                                </svg>
                                Change Mode
                            </button>
                        </div>

                        {/* Training Content - Fluid width/Order 2 on mobile */}
                        <div className="lg:w-2/3 order-first lg:order-last">
                            <div className="bg-white p-6 sm:p-8 rounded-3xl shadow-2xl border border-gray-100 min-h-[400px] flex items-center justify-center">
                                {mode === 'laser' && (
                                    <LaserMode 
                                        stats={stats} 
                                        setStats={setStats} 
                                        isRunning={stats.isRunning} 
                                    />
                                )}
                                {mode === 'camera' && (
                                    <CameraMode 
                                        stats={stats} 
                                        setStats={setStats} 
                                        isRunning={stats.isRunning} 
                                        currentExercise={cameraExercise} 
                                        setCurrentExercise={setCameraExercise} 
                                    />
                                )}
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-slate-50 font-sans p-4 sm:p-8">
                    <div className="max-w-7xl mx-auto py-8">
                        <main className="flex-grow max-w-6xl mx-auto py-4 md:py-8">
                            {content}
                        </main>
                    </div>
                </div>
            );
        };

        // Mount the application to the DOM
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
